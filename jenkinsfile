pipeline {
    agent any
    stages {
        stage('Build and Push Docker Image') {
            steps {
                sh 'mvn clean package'
                script {
                    docker.withRegistry('https://http://hub.docker.com') {
                        def app = docker.build("microsvc")
                        app.push("1.0.0")
                    }
                }
            }
        }
        stage('Deploy to Kubernetes') {
            steps {
                script {
                    def kubeconfig = readFile("${env.HOME}/.kube/config")
                    writeFile file: "${env.WORKSPACE}/kubeconfig", text: kubeconfig
                    withKubeConfig([credentialsId: 'kubeconfig-credentials', kubeconfigFile: "${env.WORKSPACE}/kubeconfig", serverUrl: 'https://my-kubernetes-cluster']) {

                        sh 'kubectl apply -f deployment.yaml'
                        sh 'kubectl apply -f service.yaml'

                        timeout(time: 5, unit: 'MINUTES') {
                            sh 'kubectl rollout status deployment/my-deployment'
                        }

                        sh 'kubectl get services'
                    }
                }
            }
        }
    }
}

	
    
       
    
    


     stages {
    stage('Clone repository') {
      steps {
        git 'https://github.com/bindupradha333/microsvc-golang/'
      }
    }
		
		/* In this stage, the code is being built/compiled, and the Docker image is being created and tagged.
         * Tests shouldn't been run in this stage, in order to speed up time to deployment.
         */
		
        stage ('MVN Build') {
          	steps {
				
				
				
				// Run the docker build command and tag the image with the git commit ID
				sh 'docker build -t bindupradha/microsvc .'
				
            }

        }

        
        /* In this stage, built images are being pushed
        */
		
        stage ('Push') {
            steps {
                
                
				// Authenticates with your remote Docker Repository, and pushes the value of "$DOCKER_PUSH_TAG",
				// which will exist if you used 'tagDocker' to tag your image, or set it manually. If you have done neither,
				// you can instead define your image using the 'image' parameter.
				// You can change the credentials used by using the 'authId' parameter.
				// The difference between this, and 'docker push $image', is that this handles 'docker login' for you.
				dockerPush()

				// Send Webex notification about docker push event status to the Webex room defined ID in the software details, using the
				// 'CoDE:ContainerHub' bot
				notifyDocker()
                
            }
        }     


        /* In this stage, we're running several different sub-stages in parallel. This speeds up job time by running many different
         * steps (that don't necessarily need to be run in sequence) at the same time, speeding up your job runtime.
         */
      		stage ('Deployment') {
            // Run these stages in parallel
            parallel {

                /* This stage simply runs your Static Security Scan. Uncomment it and include your stack name to use it.
                 */
                

                /* This steps runs your unit tests, and your SonarQube scan.
                 * This stage may vary heavily depending on your project language and structure.
                 */
                 stage ('Test/Sonar') {
					steps {
					    
						echo 'Starting SonarQube scan...'

						// Run your unit tests and prepare SonarQube output
						 
						sonarScan(sonarServer: 'Sonar', properties:'''
                            				mvn clean verify sonarsonar 
                                           -Dsonar.projectKey=product-catalogue 
                                           -Dsonar.projectName='product-catalogue' 
                                           -Dsonar.host.url=httplocalhost9000 
                                           -Dsonar.token=squ_6e793deb037a905a6a6f0d842162d6fea059f4a3
                                            sonar.jacoco.reportPaths=target/jacoco.exec
                                            sonar.core.codeCoveragePlugin=jacoco
											sonar.coverage.jacoco.xmlReportPaths=./target/site/jacoco-ut/jacoco.xml
											

                        			''')

						// This step will pause the pipeline and wait for the Sonar analysis to complete and return quality gate status.
						// The pipeline will fail if the quality gate stauts is not green
						timeout(time: 1, unit: 'HOURS') {
							script {
								def qg = waitForQualityGate() // Reuse taskId previously collected by withSonarQubeEnv
								if (qg.status != 'OK') {
									echo "Quality gate failed"
									error "Pipeline aborted due to quality gate failure: ${qg.status}"
								}
							}
						}
                    }
					// Make test results visible in Jenkins UI if the install step completed successfully
					
                


                /*stage ('Deploy') {
                    when { branch "master/*" }
                    
                }*/
				}             

                
            }
        }
    }
    
}
